mod rect;
mod shape;
mod square;
mod circle;

use crate::rect::Rect;
use crate::circle::Circle;
use crate::shape::shapes::{Greet, Shape,What};
use crate::square::Square;
fn main() {
    let r1 = Rect::new(10.12, 123.123);
    let s1 = Square::new(25.43);
    let c1: Circle = Circle::new(23.45);
    // let a1 = r1.area();
    // let p1 = r1.area();
    // Greet();
    // crate::shape::shapes::Greet();
  
    Shape2(&s1); // The code is generated
    Shape3(&r1); // The code is generated
    Shape1(&r1); // The code is generated

    Shape2(&c1); // The code is generated
    Shape3(&c1); // The code is generated
    Shape1(&c1); // The code is generated

    let i= 100;

   let str= i.what();

  // greet();
   println!("Hello Impact Analytics")
}

fn Shape1(s: &impl Shape) { 
    // this is how you can call the object s
   println!("Area of {}:{:.2}",s.what(), s.area());
   println!("perimeter of {} :{:.2}",s.what(),s.perimeter())
}

fn Shape2<T:Shape>(t:&T){
     println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}

fn Shape3<T>(t:&T) where T:Shape{
    println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}


impl What for i32{
     fn what(&self)->String{ // default implementation
            return "i32".to_string();
    }
}

impl What for bool{
   fn what(&self)->String{ // default implementation
            return "boolean".to_string();
    } 
}

struct mybool(bool);

impl std::ops::Add for mybool{
   type Output = Self;
    fn add(self, other: Self) -> Self::Output {
       mybool(true)
    }
}
// 3 types static dispatch --> code is generated by the compiler 

// creating a trait

// trait with default methods

// trait with asserted type

// trait with generic type

// using created trait as a trait bound

// use multiple traits into another trait or trait level inheritance


fn greet(){
    println!("Hello Impact Analytics")
}