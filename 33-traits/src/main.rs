mod rect;
mod shape;
mod square;
mod circle;

use crate::rect::Rect;
use crate::circle::Circle;
use crate::shape::shapes::{Greet, Shape,What};
use crate::square::Square;
fn main() {
    let r1 = Rect::new(10.12, 123.123);
    let s1 = Square::new(25.43);
    let c1: Circle = Circle::new(23.45);
    // let a1 = r1.area();
    // let p1 = r1.area();
    // Greet();
    // crate::shape::shapes::Greet();
  
    Shape2(&s1); // The code is generated
    Shape3(&r1); // The code is generated
    Shape1(&r1); // The code is generated
    Shape4(&r1); // Dynamic dispatch
    Shape4(&s1); // Dynamic dispatch
    Shape4(&c1); // Dynamic dispatch
    Shape2(&c1); // The code is generated
    Shape3(&c1); // The code is generated
    Shape1(&c1); // The code is generated

    let i= 100;

   let str= i.what();

  // greet();
   println!("Hello Impact Analytics");

   let c1:Cuboid = Cuboid { l: 12.3, b: 123.23, h: 14.56 };

   // What -> what() --> Text

   // VTable -> For every Trait and for every Concrete Type 

}

fn Shape1(s: &impl Shape) { 
    // this is how you can call the object s
   println!("Area of {}:{:.2}",s.what(), s.area());
   println!("perimeter of {} :{:.2}",s.what(),s.perimeter())
}

fn Shape2<T:Shape>(t:&T){
     println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}

fn Shape3<T>(t:&T) where T:Shape{
    println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}


fn Shape4(s: &dyn Shape) {  // dynamic dispatch, the compiler would not generate the code 
    // this is how you can call the object s
   println!("Area of {}:{:.2}",s.what(), s.area());
   println!("perimeter of {} :{:.2}",s.what(),s.perimeter())
}



impl What for i32{
     fn what(&self)->String{ // default implementation
            return "i32".to_string();
    }
}

impl What for bool{
   fn what(&self)->String{ // default implementation
            return "boolean".to_string();
    } 
}

struct mybool(bool);

impl std::ops::Add for mybool{
   type Output = Self;
    fn add(self, other: Self) -> Self::Output {
       mybool(true)
    }
}
// 3 types static dispatch --> code is generated by the compiler 

// creating a trait

// trait with default methods

// trait with asserted type

// trait with generic type

// using created trait as a trait bound

// use multiple traits into another trait or trait level inheritance


fn greet(){
    println!("Hello Impact Analytics")
}


// It does not mean that it creats a vtable 
struct Cuboid{
    l:f32,
    b:f32,
    h:f32
}

impl What for Cuboid{}