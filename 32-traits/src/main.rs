mod rect;
mod shape;
mod square;
mod circle;

use crate::rect::Rect;
use crate::circle::Circle;
use crate::shape::shapes::{Greet, Shape,What};
use crate::square::Square;
fn main() {
    let r1 = Rect::new(10.12, 123.123);
    let s1 = Square::new(25.43);
    let c1: Circle = Circle::new(23.45);
    // let a1 = r1.area();
    // let p1 = r1.area();
    // Greet();
    // crate::shape::shapes::Greet();
  
    Shape2(&s1); // The code is generated
    Shape3(&r1); // The code is generated
    Shape1(&r1,&r1); // The code is generated

    Shape2(&c1); // The code is generated
    Shape3(&c1); // The code is generated
    Shape1(&c1,&c1); // The code is generated
}

fn Shape1(s: &impl Shape,w: &impl What) { 
    // this is how you can call the object s
   println!("Area of {}:{:.2}",w.what(), s.area());
   println!("perimeter of {} :{:.2}",w.what(),s.perimeter())
}

fn Shape2<T:Shape+What>(t:&T){
     println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}

fn Shape3<T>(t:&T) where T:Shape+What{
    println!("Area of {}:{:.2}",t.what(), t.area());
    println!("perimeter of {} :{:.2}",t.what(),t.perimeter())
}


// 3 types static dispatch --> code is generated by the compiler 

// creating a trait

// trait with default methods

// trait with asserted type

// trait with generic type

// using created trait as a trait bound

// use multiple traits into another trait or trait level inheritance
